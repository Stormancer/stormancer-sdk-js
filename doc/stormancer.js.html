<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: stormancer.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: stormancer.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var Stormancer;
(function (Stormancer) {
    var ApiClient = (function () {
        function ApiClient(config, tokenHandler) {
            this.createTokenUri = "{0}/{1}/scenes/{2}/token";
            this._config = config;
            this._tokenHandler = tokenHandler;
        }
        ApiClient.prototype.getSceneEndpoint = function (accountId, applicationName, sceneId, userData) {
            var _this = this;
            var serializer = new Stormancer.MsgPackSerializer();
            //var data: Uint8Array = serializer.serialize(userData);
            var url = this._config.getApiEndpoint() + Stormancer.Helpers.stringFormat(this.createTokenUri, accountId, applicationName, sceneId);
            return $.ajax({
                type: "POST",
                url: url,
                headers: {
                    "Accept": "application/json",
                    "x-version": "1.0.0"
                },
                dataType: "json",
                contentType: "application/json",
                data: JSON.stringify(userData)
            }).then(function (result) {
                return _this._tokenHandler.decodeToken(result);
            });
        };
        return ApiClient;
    })();
    Stormancer.ApiClient = ApiClient;
})(Stormancer || (Stormancer = {}));
var Cancellation;
(function (Cancellation) {
    /**
    TokenSource
    */
    var TokenSource = (function () {
        /**
        Constructor
        */
        function TokenSource() {
            this.data = {
                reason: null,
                isCancelled: false,
                listeners: []
            };
            /**
            Token
            */
            this.token = new token(this.data);
        }
        /**
        Cancel
        */
        TokenSource.prototype.cancel = function (reason) {
            this.data.isCancelled = true;
            reason = reason || 'Operation Cancelled';
            this.data.reason = reason;
            setTimeout(function () {
                for (var i = 0; i &lt; this.data.listeners.length; i++) {
                    if (typeof this.data.listeners[i] === 'function') {
                        this.data.listeners[i](reason);
                    }
                }
            }, 0);
        };
        return TokenSource;
    })();
    Cancellation.TokenSource = TokenSource;
    /**
    Token
    */
    var token = (function () {
        /**
        Constructor
        */
        function token(data) {
            this.data = data;
        }
        /**
        To know if the token has been cancelled.
        */
        token.prototype.isCancelled = function () {
            return this.data.isCancelled;
        };
        /**
        Throw an exception if the token is cancelled.
        */
        token.prototype.throwIfCancelled = function () {
            if (this.isCancelled()) {
                throw this.data.reason;
            }
        };
        /**
        Call a function when the token is cancelled.
        */
        token.prototype.onCancelled = function (callBack) {
            if (this.isCancelled()) {
                setTimeout(function () {
                    callBack(this.data.reason);
                }, 0);
            }
            else {
                this.data.listeners.push(callBack);
            }
        };
        return token;
    })();
    Cancellation.token = token;
})(Cancellation || (Cancellation = {}));
var Stormancer;
(function (Stormancer) {
    /**
    ConnectionHandler
    */
    var ConnectionHandler = (function () {
        function ConnectionHandler() {
            this._current = 0;
        }
        /**
        Generates an unique connection id for this node.
        */
        ConnectionHandler.prototype.generateNewConnectionId = function () {
            return this._current++;
        };
        /**
        Adds a connection to the manager
        */
        ConnectionHandler.prototype.newConnection = function (connection) {
        };
        /**
        Returns a connection by id
        */
        ConnectionHandler.prototype.getConnection = function (id) {
            throw new Error("Not implemented.");
        };
        /**
        Closes the target connection
        */
        ConnectionHandler.prototype.closeConnection = function (connection, reason) {
        };
        return ConnectionHandler;
    })();
    Stormancer.ConnectionHandler = ConnectionHandler;
    var Client = (function () {
        /**
        Creates a client. You need to construct a configuration before using this method.
        @class Client
        @classdesc A Stormancer client for connecting to Stormancer server applications.
        @memberof Stormancer
        @param {Stormancer.Configuration} config The configuration object for constructing the Client.
        */
        function Client(config) {
            this._tokenHandler = new Stormancer.TokenHandler();
            this._serializers = { "msgpack/map": new Stormancer.MsgPackSerializer() };
            this._metadata = {};
            this._pluginCtx = new Stormancer.PluginBuildContext();
            /**
            The name of the Stormancer server application the client is connected to.
            @member Stormancer.Client#applicationName
            @type {string}
            */
            this.applicationName = null;
            /**
            An user specified logger.
            @member Stormancer.Client#logger
            @type {object}
            */
            this.logger = null;
            /**
            The client's unique stormancer ID. Returns null if the ID has not been acquired yet (connection still in progress).
            @member Stormancer.Client#id
            @type {string}
            */
            this.id = null;
            this.serverTransportType = null;
            this._systemSerializer = new Stormancer.MsgPackSerializer();
            /**
            The server connection's ping in milliseconds.
            @member Stormancer.Client#serverPing
            @type {number}
            */
            this.serverPing = null;
            this._pingInterval = 5000;
            this._accountId = config.account;
            this._applicationName = config.application;
            this._apiClient = new Stormancer.ApiClient(config, this._tokenHandler);
            this._transport = config.transport;
            this._dispatcher = config.dispatcher;
            this._requestProcessor = new Stormancer.RequestProcessor(this.logger, []);
            this._scenesDispatcher = new Stormancer.SceneDispatcher();
            this._dispatcher.addProcessor(this._requestProcessor);
            this._dispatcher.addProcessor(this._scenesDispatcher);
            this._metadata = config.metadata;
            for (var i = 0; i &lt; config.serializers.length; i++) {
                var serializer = config.serializers[i];
                this._serializers[serializer.name] = serializer;
            }
            this._metadata["serializers"] = Stormancer.Helpers.mapKeys(this._serializers).join(',');
            this._metadata["transport"] = this._transport.name;
            this._metadata["version"] = "1.0.0a";
            this._metadata["platform"] = "JS";
            this._metadata["protocol"] = "2";
            for (var i = 0; i &lt; config.plugins.length; i++) {
                config.plugins[i].build(this._pluginCtx);
            }
            for (var i = 0; i &lt; this._pluginCtx.clientCreated.length; i++) {
                this._pluginCtx.clientCreated[i](this);
            }
            this.initialize();
        }
        Client.prototype.initialize = function () {
            var _this = this;
            if (!this._initialized) {
                this._initialized = true;
                this._transport.packetReceived.push(function (packet) { return _this.transportPacketReceived(packet); });
            }
        };
        Client.prototype.transportPacketReceived = function (packet) {
            for (var i = 0; i &lt; this._pluginCtx.packetReceived.length; i++) {
                this._pluginCtx.packetReceived[i](packet);
            }
            this._dispatcher.dispatchPacket(packet);
        };
        /**
        Retrieve a public scene object from its ID.
        @method Stormancer.Client#getPublicScene
        @param {string} sceneId The scene ID
        @param {object} userData User data to send
        @return {Promise} Promise which complete when the scene is ready to connect.
        */
        Client.prototype.getPublicScene = function (sceneId, userData) {
            var _this = this;
            return this._apiClient.getSceneEndpoint(this._accountId, this._applicationName, sceneId, userData).then(function (ci) { return _this.getSceneImpl(sceneId, ci); });
        };
        /**
        Retrieve a scene object from its ID.
        @method Stormancer.Client#getScene
        @param {string} token Scene token
        @return {Promise} Promise which complete when the scene is ready to connect.
        */
        Client.prototype.getScene = function (token) {
            var ci = this._tokenHandler.decodeToken(token);
            return this.getSceneImpl(ci.tokenData.SceneId, ci);
        };
        Client.prototype.getSceneImpl = function (sceneId, ci) {
            var _this = this;
            var self = this;
            return this.ensureTransportStarted(ci).then(function () {
                if (ci.tokenData.Version > 0) {
                    _this.startAsyncClock();
                }
                var parameter = { Metadata: self._serverConnection.metadata, Token: ci.token };
                return self.sendSystemRequest(Stormancer.SystemRequestIDTypes.ID_GET_SCENE_INFOS, parameter);
            }).then(function (result) {
                if (!self._serverConnection.serializerChosen) {
                    if (!result.SelectedSerializer) {
                        throw new Error("No serializer selected.");
                    }
                    self._serverConnection.serializer = self._serializers[result.SelectedSerializer];
                    self._serverConnection.metadata["serializer"] = result.SelectedSerializer;
                    self._serverConnection.serializerChosen = true;
                }
                return self.updateMetadata().then(function (_) { return result; });
            }).then(function (r) {
                var scene = new Stormancer.Scene(self._serverConnection, self, sceneId, ci.token, r);
                for (var i = 0; i &lt; _this._pluginCtx.sceneCreated.length; i++) {
                    _this._pluginCtx.sceneCreated[i](scene);
                }
                return scene;
            });
        };
        Client.prototype.updateMetadata = function () {
            return this._requestProcessor.sendSystemRequest(this._serverConnection, Stormancer.SystemRequestIDTypes.ID_SET_METADATA, this._systemSerializer.serialize(this._serverConnection.metadata));
        };
        Client.prototype.sendSystemRequest = function (id, parameter) {
            var _this = this;
            return this._requestProcessor.sendSystemRequest(this._serverConnection, id, this._systemSerializer.serialize(parameter)).then(function (packet) { return _this._systemSerializer.deserialize(packet.data); });
        };
        Client.prototype.ensureTransportStarted = function (ci) {
            var self = this;
            return Stormancer.Helpers.promiseIf(self._serverConnection == null, function () {
                return Stormancer.Helpers.promiseIf(!self._transport.isRunning, self.startTransport, self).then(function () {
                    return self._transport.connect(ci.tokenData.Endpoints[self._transport.name]).then(function (c) {
                        self.registerConnection(c);
                        return self.updateMetadata();
                    });
                });
            }, self);
        };
        Client.prototype.startTransport = function () {
            this._cts = new Cancellation.TokenSource();
            return this._transport.start("client", new ConnectionHandler(), this._cts.token);
        };
        Client.prototype.registerConnection = function (connection) {
            this._serverConnection = connection;
            for (var key in this._metadata) {
                this._serverConnection.metadata[key] = this._metadata[key];
            }
        };
        Client.prototype.disconnectScene = function (scene, sceneHandle) {
            var _this = this;
            return this.sendSystemRequest(Stormancer.SystemRequestIDTypes.ID_DISCONNECT_FROM_SCENE, sceneHandle).then(function () {
                _this._scenesDispatcher.removeScene(sceneHandle);
                for (var i = 0; i &lt; _this._pluginCtx.sceneConnected.length; i++) {
                    _this._pluginCtx.sceneConnected[i](scene);
                }
            });
        };
        /**
        Disconnects the client.
        @method Stormancer.Client#disconnect
        */
        Client.prototype.disconnect = function () {
            if (this._serverConnection) {
                this._serverConnection.close();
            }
        };
        Client.prototype.connectToScene = function (scene, token, localRoutes) {
            var _this = this;
            var parameter = {
                Token: token,
                Routes: [],
                ConnectionMetadata: this._serverConnection.metadata
            };
            for (var i = 0; i &lt; localRoutes.length; i++) {
                var r = localRoutes[i];
                parameter.Routes.push({
                    Handle: r.handle,
                    Metadata: r.metadata,
                    Name: r.name
                });
            }
            return this.sendSystemRequest(Stormancer.SystemRequestIDTypes.ID_CONNECT_TO_SCENE, parameter).then(function (result) {
                scene.completeConnectionInitialization(result);
                _this._scenesDispatcher.addScene(scene);
                for (var i = 0; i &lt; _this._pluginCtx.sceneConnected.length; i++) {
                    _this._pluginCtx.sceneConnected[i](scene);
                }
            });
        };
        Client.prototype.getCurrentTimestamp = function () {
            return (window.performance &amp;&amp; window.performance.now &amp;&amp; window.performance.now()) || Date.now();
        };
        Client.prototype.startAsyncClock = function () {
            if (!this.syncClockIntervalId) {
                this.syncClockIntervalId = setInterval(this.syncClockImpl.bind(this), this._pingInterval);
            }
        };
        Client.prototype.stopAsyncClock = function () {
            clearInterval(this.syncClockIntervalId);
            this.syncClockIntervalId = null;
        };
        Client.prototype.syncClockImpl = function () {
            var _this = this;
            try {
                var timeStart = Math.floor(this.getCurrentTimestamp());
                var data = new Uint32Array(2);
                data[0] = timeStart;
                data[1] = Math.floor(timeStart / Math.pow(2, 32));
                this._requestProcessor.sendSystemRequest(this._serverConnection, Stormancer.SystemRequestIDTypes.ID_PING, new Uint8Array(data.buffer), 0 /* IMMEDIATE_PRIORITY */).done(function (packet) {
                    var timeEnd = _this.getCurrentTimestamp();
                    var data = new Uint8Array(packet.data.buffer, packet.data.byteOffset, 8);
                    var timeRef = 0;
                    for (var i = 0; i &lt; 8; i++) {
                        timeRef += (data[i] * Math.pow(2, (i * 8)));
                    }
                    _this.serverPing = timeEnd - timeStart;
                    _this._offset = timeRef - (_this.serverPing / 2) - timeStart;
                }).fail(function (e) { return console.error("ping: Failed to ping server.", e); });
            }
            catch (e) {
                console.error("ping: Failed to ping server.", e);
            }
        };
        /**
        Get the server clock. Represented by the count of milliseconds since the cluster started.
        @method Stormancer.Client#clock
        @return {number} The number of milliseconds since the application started.
        */
        Client.prototype.clock = function () {
            return Math.floor(this.getCurrentTimestamp()) + this._offset;
        };
        return Client;
    })();
    Stormancer.Client = Client;
})(Stormancer || (Stormancer = {}));
var Stormancer;
(function (Stormancer) {
    var Configuration = (function () {
        /**
        Creates a Configuration. Prefer the **Configuration.forAccount** method instead of this constructor.
        @class Configuration
        @classdesc Represents the configuration of a Stormancer client. Use the static method **Configuration.forAccount** for creating a Configuration with an account ID and an application name.
        @memberof Stormancer
        */
        function Configuration() {
            /**
            A string containing the target server endpoint.
            This value overrides the *apiEndpoint* property.
            @member Stormancer.Configuration#serverEndpoint
            @type {string}
            */
            this.serverEndpoint = "";
            /**
            A string containing the account name of the application.
            @member Stormancer.Configuration#account
            @type {string}
            */
            this.account = "";
            /**
            A string containing the name of the application.
            @member Stormancer.Configuration#application
            @type {string}
            */
            this.application = "";
            /**
            The plugins list
            */
            this.plugins = [];
            /**
            The metadatas to send for connexion
            */
            this.metadata = {};
            /**
            Gets or Sets the dispatcher to be used by the client.
            @member Stormancer.Configuration#dispatcher
            @type {object}
            */
            this.dispatcher = null;
            /**
            Gets or sets the transport to be used by the client.
            @member Stormancer.Configuration#transport
            @type {object}
            */
            this.transport = null;
            /**
            List of available serializers for the client.
            When negotiating which serializer should be used for a given remote peer, the first compatible serializer in the list is the one prefered.
            @member Stormancer.Configuration#serializers
            @type {object[]}
            */
            this.serializers = [];
            this.transport = new Stormancer.WebSocketTransport();
            this.dispatcher = new Stormancer.DefaultPacketDispatcher();
            this.serializers = [];
            this.serializers.push(new Stormancer.MsgPackSerializer());
            this.plugins.push(new Stormancer.RpcClientPlugin());
        }
        /**
        Creates a Configuration object targeting the public online platform.
        @method Stormancer.Configuration#forAccount
        @param {string} accountId Account ID
        @param {string} applicationName Application name
        @return {Stormancer.Configuration} The configuration object
        */
        Configuration.forAccount = function (accountId, applicationName) {
            var config = new Configuration();
            config.account = accountId;
            config.application = applicationName;
            return config;
        };
        /**
        Returns the API Endpoint URI to use.
        @return {string} API Endpoint URI
        */
        Configuration.prototype.getApiEndpoint = function () {
            return this.serverEndpoint ? this.serverEndpoint : Configuration.apiEndpoint;
        };
        /**
        Adds metadata to the connection.
        @param {string} key
        @param {string} value
        @return {Configuration} this
        */
        Configuration.prototype.Metadata = function (key, value) {
            this.metadata[key] = value;
            return this;
        };
        /**
        API Endpoint URI
        */
        Configuration.apiEndpoint = "https://api.stormancer.com/";
        return Configuration;
    })();
    Stormancer.Configuration = Configuration;
})(Stormancer || (Stormancer = {}));
var Stormancer;
(function (Stormancer) {
    /**
    @alias ConnectionState
    @enum {number}
    @memberof Stormancer
    */
    var _ = {
        Disconnected: 0,
        Connecting: 1,
        Connected: 2
    };
    (function (ConnectionState) {
        ConnectionState[ConnectionState["Disconnected"] = 0] = "Disconnected";
        ConnectionState[ConnectionState["Connecting"] = 1] = "Connecting";
        ConnectionState[ConnectionState["Connected"] = 2] = "Connected";
    })(Stormancer.ConnectionState || (Stormancer.ConnectionState = {}));
    var ConnectionState = Stormancer.ConnectionState;
})(Stormancer || (Stormancer = {}));
var Stormancer;
(function (Stormancer) {
    var Packet = (function () {
        /**
        A packet sent by a remote peer to the running peer.
        @class Packet
        @classdesc A packet sent by a remote peer to the running peer.
        @memberof Stormancer
        */
        function Packet(source, data, metadata) {
            /**
            Metadata stored by the packet.
            @member Stormancer.Packet#metadata
            @type {object.&lt;string, object>}
            */
            this.metadata = {};
            this.connection = source;
            this.data = data;
            this.metadata = metadata;
        }
        Packet.prototype.setMetadata = function (metadata) {
            this.metadata = metadata;
        };
        Packet.prototype.getMetadata = function () {
            if (!this.metadata) {
                this.metadata = {};
            }
            return this.metadata;
        };
        Packet.prototype.setMetadataValue = function (key, value) {
            if (!this.metadata) {
                this.metadata = {};
            }
            this.metadata[key] = value;
        };
        /**
        Returns metadata
        @param {string} key
        @return {string} Key associated object
        */
        Packet.prototype.getMetadataValue = function (key) {
            if (!this.metadata) {
                this.metadata = {};
            }
            return this.metadata[key];
        };
        return Packet;
    })();
    Stormancer.Packet = Packet;
})(Stormancer || (Stormancer = {}));
var Stormancer;
(function (Stormancer) {
    // Available packet priorities
    (function (PacketPriority) {
        // The packet is sent immediately without aggregation.
        PacketPriority[PacketPriority["IMMEDIATE_PRIORITY"] = 0] = "IMMEDIATE_PRIORITY";
        // The packet is sent at high priority level.
        PacketPriority[PacketPriority["HIGH_PRIORITY"] = 1] = "HIGH_PRIORITY";
        // The packet is sent at medium priority level.
        PacketPriority[PacketPriority["MEDIUM_PRIORITY"] = 2] = "MEDIUM_PRIORITY";
        // The packet is sent at low priority level.
        PacketPriority[PacketPriority["LOW_PRIORITY"] = 3] = "LOW_PRIORITY";
    })(Stormancer.PacketPriority || (Stormancer.PacketPriority = {}));
    var PacketPriority = Stormancer.PacketPriority;
})(Stormancer || (Stormancer = {}));
var Stormancer;
(function (Stormancer) {
    /// Different available reliability levels when sending a packet.
    (function (PacketReliability) {
        /// The packet may be lost, or arrive out of order. There are no guarantees whatsoever.
        PacketReliability[PacketReliability["UNRELIABLE"] = 0] = "UNRELIABLE";
        /// The packets arrive in order, but may be lost. If a packet arrives out of order, it is discarded.
        /// The last packet may also never arrive.
        PacketReliability[PacketReliability["UNRELIABLE_SEQUENCED"] = 1] = "UNRELIABLE_SEQUENCED";
        /// The packets always reach destination, but may do so out of order.
        PacketReliability[PacketReliability["RELIABLE"] = 2] = "RELIABLE";
        /// The packets always reach destination and in order.
        PacketReliability[PacketReliability["RELIABLE_ORDERED"] = 3] = "RELIABLE_ORDERED";
        /// The packets arrive at destination in order. If a packet arrive out of order, it is ignored.
        /// That mean that packets may disappear, but the last one always reach destination.
        PacketReliability[PacketReliability["RELIABLE_SEQUENCED"] = 4] = "RELIABLE_SEQUENCED";
    })(Stormancer.PacketReliability || (Stormancer.PacketReliability = {}));
    var PacketReliability = Stormancer.PacketReliability;
})(Stormancer || (Stormancer = {}));
var Stormancer;
(function (Stormancer) {
    var Route = (function () {
        /**
        Creates a new route instance.
        @class Route
        @classdesc Represents a Route on a Scene.
        @memberof Stormancer
        @param {Stormancer.Scene} scene The scene instance
        @param {string} name The route name.
        @param {number} handle Handle of the route (16 bits unsigned integer).
        @param {object.&lt;string, string>} metadata Metadata attached to this route.
        */
        function Route(scene, name, handle, metadata) {
            if (handle === void 0) { handle = 0; }
            if (metadata === void 0) { metadata = {}; }
            /**
            The Scene instance which contains this route.
            @member Stormancer.Packet#scene
            @type {Stormancer.Scene}
            */
            this.scene = null;
            /**
            A string containing the name of the route.
            @member Stormancer.Packet#name
            @type {string}
            */
            this.name = null;
            /**
            Route handle.
            @member Stormancer.Packet#handle
            @type {number}
            */
            this.handle = null;
            /**
            Route metadata.
            @member Stormancer.Packet#metadata
            @type {object.&lt;string, string>}
            */
            this.metadata = {};
            /**
            Contains the handlers that are run when packets are received.
            @member Stormancer.Packet#handlers
            @type {function[]}
            */
            this.handlers = [];
            this.scene = scene;
            this.name = name;
            this.handle = handle;
            this.metadata = metadata;
        }
        return Route;
    })();
    Stormancer.Route = Route;
})(Stormancer || (Stormancer = {}));
var Stormancer;
(function (Stormancer) {
    var Helpers = (function () {
        function Helpers() {
        }
        Helpers.base64ToByteArray = function (data) {
            return new Uint8Array(atob(data).split('').map(function (c) {
                return c.charCodeAt(0);
            }));
        };
        Helpers.stringFormat = function (str) {
            var args = [];
            for (var _i = 1; _i &lt; arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            for (var i in args) {
                str = str.replace('{' + i + '}', args[i]);
            }
            return str;
        };
        Helpers.mapKeys = function (map) {
            var keys = [];
            for (var key in map) {
                if (map.hasOwnProperty(key)) {
                    keys.push(key);
                }
            }
            return keys;
        };
        Helpers.mapValues = function (map) {
            var result = [];
            for (var key in map) {
                result.push(map[key]);
            }
            return result;
        };
        Helpers.promiseFromResult = function (result) {
            var deferred = jQuery.Deferred();
            deferred.resolve(result);
            return deferred.promise();
        };
        Helpers.promiseIf = function (condition, action, context) {
            if (condition) {
                if (context) {
                    return action.call(context);
                }
                else {
                    return action();
                }
            }
            else {
                return Helpers.promiseFromResult(null);
            }
        };
        return Helpers;
    })();
    Stormancer.Helpers = Helpers;
})(Stormancer || (Stormancer = {}));
var Stormancer;
(function (Stormancer) {
    var DefaultPacketDispatcher = (function () {
        function DefaultPacketDispatcher() {
            this._handlers = {};
            this._defaultProcessors = [];
        }
        DefaultPacketDispatcher.prototype.dispatchPacket = function (packet) {
            var processed = false;
            var count = 0;
            var msgType = 0;
            while (!processed &amp;&amp; count &lt; 40) {
                msgType = packet.data[0];
                packet.data = packet.data.subarray(1);
                if (this._handlers[msgType]) {
                    processed = this._handlers[msgType](packet);
                    count++;
                }
                else {
                    break;
                }
            }
            for (var i = 0, len = this._defaultProcessors.length; i &lt; len; i++) {
                if (this._defaultProcessors[i](msgType, packet)) {
                    processed = true;
                    break;
                }
            }
            if (!processed) {
                throw new Error("Couldn't process message. msgId: " + msgType);
            }
        };
        DefaultPacketDispatcher.prototype.addProcessor = function (processor) {
            processor.registerProcessor(new Stormancer.PacketProcessorConfig(this._handlers, this._defaultProcessors));
        };
        return DefaultPacketDispatcher;
    })();
    Stormancer.DefaultPacketDispatcher = DefaultPacketDispatcher;
})(Stormancer || (Stormancer = {}));
var Stormancer;
(function (Stormancer) {
    var TokenHandler = (function () {
        function TokenHandler() {
            this._tokenSerializer = new Stormancer.MsgPackSerializer();
        }
        TokenHandler.prototype.decodeToken = function (token) {
            var data = token.split('-')[0];
            var buffer = Stormancer.Helpers.base64ToByteArray(data);
            var result = this._tokenSerializer.deserialize(buffer);
            var sceneEndpoint = new Stormancer.SceneEndpoint();
            sceneEndpoint.token = token;
            sceneEndpoint.tokenData = result;
            return sceneEndpoint;
        };
        return TokenHandler;
    })();
    Stormancer.TokenHandler = TokenHandler;
})(Stormancer || (Stormancer = {}));
var Stormancer;
(function (Stormancer) {
    var MsgPackSerializer = (function () {
        function MsgPackSerializer() {
            this.name = "msgpack/map";
        }
        MsgPackSerializer.prototype.serialize = function (data) {
            return new Uint8Array(msgpack.pack(data));
        };
        MsgPackSerializer.prototype.deserialize = function (bytes) {
            return msgpack.unpack(bytes);
        };
        return MsgPackSerializer;
    })();
    Stormancer.MsgPackSerializer = MsgPackSerializer;
})(Stormancer || (Stormancer = {}));
var Stormancer;
(function (Stormancer) {
    // Contains method to register handlers for message types when passed to the IPacketProcessor.RegisterProcessor method.
    var PacketProcessorConfig = (function () {
        function PacketProcessorConfig(handlers, defaultprocessors) {
            this._handlers = handlers;
            this._defaultProcessors = defaultprocessors;
        }
        // Adds an handler for the specified message type.
        PacketProcessorConfig.prototype.addProcessor = function (msgId, handler) {
            if (this._handlers[msgId]) {
                throw new Error("An handler is already registered for id " + msgId);
            }
            this._handlers[msgId] = handler;
        };
        // Adds
        PacketProcessorConfig.prototype.addCatchAllProcessor = function (handler) {
            this._defaultProcessors.push(function (n, p) { return handler(n, p); });
        };
        return PacketProcessorConfig;
    })();
    Stormancer.PacketProcessorConfig = PacketProcessorConfig;
})(Stormancer || (Stormancer = {}));
var Stormancer;
(function (Stormancer) {
    var MessageIDTypes = (function () {
        function MessageIDTypes() {
        }
        MessageIDTypes.ID_SYSTEM_REQUEST = 134;
        MessageIDTypes.ID_REQUEST_RESPONSE_MSG = 137;
        MessageIDTypes.ID_REQUEST_RESPONSE_COMPLETE = 138;
        MessageIDTypes.ID_REQUEST_RESPONSE_ERROR = 139;
        MessageIDTypes.ID_CONNECTION_RESULT = 140;
        MessageIDTypes.ID_SCENES = 141;
        return MessageIDTypes;
    })();
    Stormancer.MessageIDTypes = MessageIDTypes;
    var SystemRequestIDTypes = (function () {
        function SystemRequestIDTypes() {
        }
        SystemRequestIDTypes.ID_GET_SCENE_INFOS = 136;
        SystemRequestIDTypes.ID_CONNECT_TO_SCENE = 134;
        SystemRequestIDTypes.ID_SET_METADATA = 0;
        SystemRequestIDTypes.ID_SCENE_READY = 1;
        SystemRequestIDTypes.ID_PING = 2;
        SystemRequestIDTypes.ID_DISCONNECT_FROM_SCENE = 135;
        return SystemRequestIDTypes;
    })();
    Stormancer.SystemRequestIDTypes = SystemRequestIDTypes;
})(Stormancer || (Stormancer = {}));
var Stormancer;
(function (Stormancer) {
    var PluginBuildContext = (function () {
        function PluginBuildContext() {
            /// &lt;summary>
            /// Event fired when a scene object is created.
            /// &lt;/summary>
            this.sceneCreated = [];
            /// &lt;summary>
            /// Event fired when a client object is created.
            /// &lt;/summary>
            this.clientCreated = [];
            /// &lt;summary>
            /// Event fired when a a scene is connected to the server.
            /// &lt;/summary>
            this.sceneConnected = [];
            /// &lt;summary>
            /// Event fired when a scene is disconnected.
            /// &lt;/summary>
            this.sceneDisconnected = [];
            /// &lt;summary>
            /// Event fired when a packet is received from a remote peer.
            /// &lt;/summary>
            this.packetReceived = [];
        }
        return PluginBuildContext;
    })();
    Stormancer.PluginBuildContext = PluginBuildContext;
})(Stormancer || (Stormancer = {}));
var Stormancer;
(function (Stormancer) {
    var RequestContext = (function () {
        function RequestContext(p) {
            this._didSendValues = false;
            this.isComplete = false;
            this._packet = p;
            this._requestId = p.data.subarray(0, 2);
            this.inputData = p.data.subarray(2);
        }
        RequestContext.prototype.send = function (data) {
            if (this.isComplete) {
                throw new Error("The request is already completed.");
            }
            this._didSendValues = true;
            var dataToSend = new Uint8Array(2 + data.length);
            dataToSend.set(this._requestId);
            dataToSend.set(data, 2);
            this._packet.connection.sendSystem(Stormancer.MessageIDTypes.ID_REQUEST_RESPONSE_MSG, dataToSend);
        };
        RequestContext.prototype.complete = function () {
            var dataToSend = new Uint8Array(3);
            dataToSend.set(this._requestId);
            dataToSend.set(2, this._didSendValues ? 1 : 0);
            this._packet.connection.sendSystem(Stormancer.MessageIDTypes.ID_REQUEST_RESPONSE_COMPLETE, dataToSend);
        };
        RequestContext.prototype.error = function (data) {
            var dataToSend = new Uint8Array(2 + data.length);
            dataToSend.set(this._requestId);
            dataToSend.set(data, 2);
            this._packet.connection.sendSystem(Stormancer.MessageIDTypes.ID_REQUEST_RESPONSE_ERROR, dataToSend);
        };
        return RequestContext;
    })();
    Stormancer.RequestContext = RequestContext;
})(Stormancer || (Stormancer = {}));
var Stormancer;
(function (Stormancer) {
    var RpcClientPlugin = (function () {
        function RpcClientPlugin() {
        }
        RpcClientPlugin.prototype.build = function (ctx) {
            ctx.sceneCreated.push(function (scene) {
                var rpcParams = scene.getHostMetadata(RpcClientPlugin.PluginName);
                if (rpcParams == RpcClientPlugin.Version) {
                    var processor = new Stormancer.RpcService(scene);
                    scene.registerComponent(RpcClientPlugin.ServiceName, function () { return processor; });
                    scene.addRoute(RpcClientPlugin.NextRouteName, function (p) {
                        processor.next(p);
                    });
                    scene.addRoute(RpcClientPlugin.ErrorRouteName, function (p) {
                        processor.error(p);
                    });
                    scene.addRoute(RpcClientPlugin.CompletedRouteName, function (p) {
                        processor.complete(p);
                    });
                }
            });
        };
        RpcClientPlugin.NextRouteName = "stormancer.rpc.next";
        RpcClientPlugin.ErrorRouteName = "stormancer.rpc.error";
        RpcClientPlugin.CompletedRouteName = "stormancer.rpc.completed";
        RpcClientPlugin.Version = "1.0.0";
        RpcClientPlugin.PluginName = "stormancer.plugins.rpc";
        RpcClientPlugin.ServiceName = "rpcService";
        return RpcClientPlugin;
    })();
    Stormancer.RpcClientPlugin = RpcClientPlugin;
})(Stormancer || (Stormancer = {}));
var Stormancer;
(function (Stormancer) {
    var RpcService = (function () {
        function RpcService(scene) {
            this._currentRequestId = 0;
            this._pendingRequests = {};
            this._scene = scene;
        }
        RpcService.prototype.RpcRaw = function (route, data, onNext, onError, onCompleted, priority) {
            var _this = this;
            if (onError === void 0) { onError = function (error) {
            }; }
            if (onCompleted === void 0) { onCompleted = function () {
            }; }
            if (priority === void 0) { priority = 2 /* MEDIUM_PRIORITY */; }
            var remoteRoutes = this._scene.getRemoteRoutes();
            var relevantRoute;
            for (var i = 0; i &lt; remoteRoutes.length; i++) {
                if (remoteRoutes[i].name == route) {
                    relevantRoute = remoteRoutes[i];
                    break;
                }
            }
            if (!relevantRoute) {
                throw new Error("The target route does not exist on the remote host.");
            }
            if (relevantRoute.metadata[Stormancer.RpcClientPlugin.PluginName] != Stormancer.RpcClientPlugin.Version) {
                throw new Error("The target remote route does not support the plugin RPC version " + Stormancer.RpcClientPlugin.Version);
            }
            var deferred = jQuery.Deferred();
            var observer = {
                onNext: onNext,
                onError: function (error) {
                    onError(error);
                    deferred.reject(error);
                },
                onCompleted: function () {
                    onCompleted();
                    deferred.resolve();
                }
            };
            var id = this.reserveId();
            var request = {
                observer: observer,
                deferred: deferred,
                receivedMessages: 0,
                id: id
            };
            this._pendingRequests[id] = request;
            var dataToSend = new Uint8Array(2 + data.length);
            dataToSend.set([i &amp; 255, i >>> 8]);
            dataToSend.set(data, 2);
            this._scene.sendPacket(route, dataToSend, priority, 3 /* RELIABLE_ORDERED */);
            return {
                unsubscribe: function () {
                    delete _this._pendingRequests[id];
                }
            };
        };
        RpcService.prototype.reserveId = function () {
            var loop = 0;
            while (this._pendingRequests[this._currentRequestId]) {
                loop++;
                this._currentRequestId = (this._currentRequestId + 1) &amp; 65535;
                if (loop > 65535) {
                    throw new Error("Too many requests in progress, unable to start a new one.");
                }
            }
            return this._currentRequestId;
        };
        //finds the appropriate pending request and consumes the first 2 bytes of the packet.
        RpcService.prototype.getPendingRequest = function (packet) {
            var id = packet.data[0] + 256 * packet.data[1];
            packet.data = packet.data.subarray(2);
            return this._pendingRequests[id];
        };
        RpcService.prototype.next = function (packet) {
            var request = this.getPendingRequest(packet);
            if (request) {
                request.receivedMessages++;
                request.observer.onNext(packet);
                if (request.deferred.state() == "pending") {
                    request.deferred.resolve();
                }
            }
        };
        RpcService.prototype.error = function (packet) {
            var request = this.getPendingRequest(packet);
            if (request) {
                request.observer.onError(packet.connection.serializer.deserialize(packet.data));
                delete this._pendingRequests[request.id];
            }
        };
        RpcService.prototype.complete = function (packet) {
            var _this = this;
            var messageSent = packet.data[0];
            packet.data = packet.data.subarray(1);
            var request = this.getPendingRequest(packet);
            if (request) {
                if (messageSent) {
                    request.deferred.then(function () {
                        request.observer.onCompleted();
                        delete _this._pendingRequests[request.id];
                    });
                }
                else {
                    request.observer.onCompleted();
                    delete this._pendingRequests[request.id];
                }
            }
        };
        return RpcService;
    })();
    Stormancer.RpcService = RpcService;
})(Stormancer || (Stormancer = {}));
///&lt;reference path="../MessageIDTypes.ts"/>
var Stormancer;
(function (Stormancer) {
    var RequestProcessor = (function () {
        function RequestProcessor(logger, modules) {
            this._pendingRequests = {};
            this._isRegistered = false;
            this._handlers = {};
            this._pendingRequests = {};
            this._logger = logger;
            for (var key in modules) {
                var mod = modules[key];
                mod.register(this.addSystemRequestHandler);
            }
        }
        RequestProcessor.prototype.registerProcessor = function (config) {
            var _this = this;
            this._isRegistered = true;
            for (var key in this._handlers) {
                var handler = this._handlers[key];
                config.addProcessor(key, function (p) {
                    var context = new Stormancer.RequestContext(p);
                    var continuation = function (fault) {
                        if (!context.isComplete) {
                            if (fault) {
                                context.error(p.connection.serializer.serialize(fault));
                            }
                            else {
                                context.complete();
                            }
                        }
                    };
                    handler(context).done(function () { return continuation(null); }).fail(function (error) { return continuation(error); });
                    return true;
                });
            }
            config.addProcessor(Stormancer.MessageIDTypes.ID_REQUEST_RESPONSE_MSG, function (p) {
                var id = new DataView(p.data.buffer, p.data.byteOffset).getUint16(0, true);
                var request = _this._pendingRequests[id];
                if (request) {
                    p.setMetadataValue["request"] = request;
                    request.lastRefresh = new Date();
                    p.data = p.data.subarray(2);
                    request.observer.onNext(p);
                    request.deferred.resolve();
                }
                else {
                    console.error("Unknow request id.");
                    return true;
                }
                return true;
            });
            config.addProcessor(Stormancer.MessageIDTypes.ID_REQUEST_RESPONSE_COMPLETE, function (p) {
                var id = new DataView(p.data.buffer, p.data.byteOffset).getUint16(0, true);
                var request = _this._pendingRequests[id];
                if (request) {
                    p.setMetadataValue("request", request);
                }
                else {
                    console.error("Unknow request id.");
                    return true;
                }
                delete _this._pendingRequests[id];
                if (p.data[3]) {
                    request.deferred.promise().always(function () { return request.observer.onCompleted(); });
                }
                else {
                    request.observer.onCompleted();
                }
                return true;
            });
            config.addProcessor(Stormancer.MessageIDTypes.ID_REQUEST_RESPONSE_ERROR, function (p) {
                var id = new DataView(p.data.buffer, p.data.byteOffset).getUint16(0, true);
                var request = _this._pendingRequests[id];
                if (request) {
                    p.setMetadataValue("request", request);
                }
                else {
                    console.error("Unknow request id.");
                    return true;
                }
                delete _this._pendingRequests[id];
                var msg = p.connection.serializer.deserialize(p.data.subarray(2));
                request.observer.onError(new Error(msg));
                return true;
            });
        };
        RequestProcessor.prototype.addSystemRequestHandler = function (msgId, handler) {
            if (this._isRegistered) {
                throw new Error("Can only add handler before 'registerProcessor' is called.");
            }
            this._handlers[msgId] = handler;
        };
        RequestProcessor.prototype.reserveRequestSlot = function (observer) {
            var id = 0;
            this.toto = 1;
            while (id &lt; 65535) {
                if (!this._pendingRequests[id]) {
                    var request = { lastRefresh: new Date, id: id, observer: observer, deferred: jQuery.Deferred() };
                    this._pendingRequests[id] = request;
                    return request;
                }
                id++;
            }
            throw new Error("Unable to create new request: Too many pending requests.");
        };
        RequestProcessor.prototype.sendSystemRequest = function (peer, msgId, data, priority) {
            if (priority === void 0) { priority = 2 /* MEDIUM_PRIORITY */; }
            var deferred = $.Deferred();
            var request = this.reserveRequestSlot({
                onNext: function (packet) {
                    deferred.resolve(packet);
                },
                onError: function (e) {
                    deferred.reject(e);
                },
                onCompleted: function () {
                    deferred.resolve();
                }
            });
            var dataToSend = new Uint8Array(3 + data.length);
            var idArray = new Uint16Array([request.id]);
            dataToSend.set([msgId], 0);
            dataToSend.set(new Uint8Array(idArray.buffer), 1);
            dataToSend.set(data, 3);
            peer.sendSystem(Stormancer.MessageIDTypes.ID_SYSTEM_REQUEST, dataToSend, priority);
            return deferred.promise();
        };
        return RequestProcessor;
    })();
    Stormancer.RequestProcessor = RequestProcessor;
})(Stormancer || (Stormancer = {}));
var Stormancer;
(function (Stormancer) {
    var SceneDispatcher = (function () {
        function SceneDispatcher() {
            this._scenes = [];
            this._buffers = [];
        }
        SceneDispatcher.prototype.registerProcessor = function (config) {
            var _this = this;
            config.addCatchAllProcessor(function (handler, packet) { return _this.handler(handler, packet); });
        };
        SceneDispatcher.prototype.handler = function (sceneHandle, packet) {
            if (sceneHandle &lt; Stormancer.MessageIDTypes.ID_SCENES) {
                return false;
            }
            var scene = this._scenes[sceneHandle - Stormancer.MessageIDTypes.ID_SCENES];
            if (!scene) {
                var buffer;
                if (this._buffers[sceneHandle] == undefined) {
                    buffer = [];
                    this._buffers[sceneHandle] = buffer;
                }
                else {
                    buffer = this._buffers[sceneHandle];
                }
                buffer.push(packet);
                return true;
            }
            else {
                packet.setMetadataValue("scene", scene);
                scene.handleMessage(packet);
                return true;
            }
        };
        SceneDispatcher.prototype.addScene = function (scene) {
            this._scenes[scene.handle - Stormancer.MessageIDTypes.ID_SCENES] = scene;
            if (this._buffers[scene.handle] != undefined) {
                var buffer = this._buffers[scene.handle];
                delete this._buffers[scene.handle];
                while (buffer.length > 0) {
                    var packet = buffer.pop();
                    packet.setMetadataValue("scene", scene);
                    scene.handleMessage(packet);
                }
            }
        };
        SceneDispatcher.prototype.removeScene = function (sceneHandle) {
            delete this._scenes[sceneHandle - Stormancer.MessageIDTypes.ID_SCENES];
        };
        return SceneDispatcher;
    })();
    Stormancer.SceneDispatcher = SceneDispatcher;
})(Stormancer || (Stormancer = {}));
var Stormancer;
(function (Stormancer) {
    var Scene = (function () {
        /**
        A Scene should not be created by the user. Get a Scene by using **Client#getPublicScene** or **Client#getScene**.
        @class Scene
        @classdesc A Stormancer scene. Peers connected to a Scene can interact between themself.
        @memberof Stormancer
        */
        function Scene(connection, client, id, token, dto) {
            /**
            A byte representing the index of the scene for this peer.
            @member Stormancer.Scene#handle
            @type {number}
            */
            this.handle = null;
            /**
            A boolean representing whether the scene is connected or not.
            @member Stormancer.Scene#connected
            @type {boolean}
            */
            this.connected = false;
            /**
            Returns a list of the routes registered on the local peer.
            @member Stormancer.Scene#localRoutes
            @type {Object.&lt;string, object>}
            */
            this.localRoutes = {};
            /**
            Returns a list of the routes available on the remote peer.
            @member Stormancer.Scene#remoteRoutes
            @type {Object.&lt;string, object>}
            */
            this.remoteRoutes = {};
            this._handlers = {};
            /**
            Pool of functions called when a packet is received.
            @member Stormancer.Scene#packetReceived
            @type {function[]}
            */
            this.packetReceived = [];
            this._registeredComponents = {};
            this.id = id;
            this.hostConnection = connection;
            this._token = token;
            this._client = client;
            this._metadata = dto.Metadata;
            for (var i = 0; i &lt; dto.Routes.length; i++) {
                var route = dto.Routes[i];
                this.remoteRoutes[route.Name] = new Stormancer.Route(this, route.Name, route.Handle, route.Metadata);
            }
        }
        /**
        Returns metadata informations for the remote scene host.
        @param {string} key
        @return {string} Key associated value
        */
        Scene.prototype.getHostMetadata = function (key) {
            return this._metadata[key];
        };
        // Registers a route on the local peer.
        Scene.prototype.addRoute = function (route, handler, metadata) {
            if (metadata === void 0) { metadata = {}; }
            if (route[0] === "@") {
                throw new Error("A route cannot start with the @ character.");
            }
            if (this.connected) {
                throw new Error("You cannot register handles once the scene is connected.");
            }
            var routeObj = this.localRoutes[route];
            if (!routeObj) {
                routeObj = new Stormancer.Route(this, route, 0, metadata);
                this.localRoutes[route] = routeObj;
            }
            this.onMessageImpl(routeObj, handler);
        };
        /**
        Allows to receive messages on a route. A route is an easy way to get messages of only one type.
        @method Stormancer.Scene#registerRoute
        @param {string} route The route name
        @param {function} handler Function for handling the received messages. This function is called any time a data is received by the server on this route. The data is the first parameter of the function.
        */
        Scene.prototype.registerRoute = function (route, handler) {
            var _this = this;
            this.addRoute(route, function (packet) {
                var message = _this.hostConnection.serializer.deserialize(packet.data);
                handler(message);
            });
        };
        /**
        Allows to receive messages on a route without using any built-in serializers. Use this method for serialize and deserialize data by yourself.
        @method Stormancer.Scene#registerRouteRaw
        @param {string} route The route name
        @param {function} handler Function for handling the received messages. This function is called any time a data is received by the server on this route. The data is the first parameter of the function.
        */
        Scene.prototype.registerRouteRaw = function (route, handler) {
            this.addRoute(route, function (packet) {
                handler(new DataView(packet.data.buffer, packet.data.byteOffset));
            });
        };
        Scene.prototype.onMessageImpl = function (route, handler) {
            var _this = this;
            var action = function (p) {
                var packet = new Stormancer.Packet(_this.host(), p.data, p.getMetadata());
                handler(packet);
            };
            route.handlers.push(function (p) { return action(p); });
        };
        /**
        Sends a binary packet to the scene.
        @method Stormancer.Scene#sendPacket
        @param {string} route The route name.
        @param {Uint8Array} data The data to send.
        @param {number} priority The packet priority on the stormancer network.
        @param {number} reliability The packet reliability on the stormancer network.
        */
        Scene.prototype.sendPacket = function (route, data, priority, reliability) {
            if (priority === void 0) { priority = 2 /* MEDIUM_PRIORITY */; }
            if (reliability === void 0) { reliability = 2 /* RELIABLE */; }
            if (!route) {
                throw new Error("route is null or undefined!");
            }
            if (!data) {
                throw new Error("data is null or undefind!");
            }
            if (!this.connected) {
                throw new Error("The scene must be connected to perform this operation.");
            }
            var routeObj = this.remoteRoutes[route];
            if (!routeObj) {
                throw new Error("The route " + route + " doesn't exist on the scene.");
            }
            this.hostConnection.sendToScene(this.handle, routeObj.handle, data, priority, reliability);
        };
        /**
        Sends an object to the scene.
        @method Stormancer.Scene#send
        @param {string} route The route name.
        @param {object} data The data to send.
        @param {number} priority The packet priority on the stormancer network.
        @param {number} reliability The packet reliability on the stormancer network.
        */
        Scene.prototype.send = function (route, data, priority, reliability) {
            if (priority === void 0) { priority = 2 /* MEDIUM_PRIORITY */; }
            if (reliability === void 0) { reliability = 2 /* RELIABLE */; }
            return this.sendPacket(route, this.hostConnection.serializer.serialize(data), priority, reliability);
        };
        /**
        Connect the Scene to the Stormancer application scene.
        @method Stormancer.Scene#connect
        @return {Promise} A promise which complete when the Scene is connected.
        */
        Scene.prototype.connect = function () {
            var _this = this;
            return this._client.connectToScene(this, this._token, Stormancer.Helpers.mapValues(this.localRoutes)).then(function () {
                _this.connected = true;
            });
        };
        /**
        Disconnect the Scene.
        @method Stormancer.Scene#disconnect
        @return {Promise} A promise which complete when the Scene is disconnected.
        */
        Scene.prototype.disconnect = function () {
            return this._client.disconnectScene(this, this.handle);
        };
        Scene.prototype.handleMessage = function (packet) {
            var ev = this.packetReceived;
            ev &amp;&amp; ev.map(function (value) {
                value(packet);
            });
            // extract the route id
            var routeId = new DataView(packet.data.buffer, packet.data.byteOffset).getUint16(0, true);
            packet.data = packet.data.subarray(2);
            packet.setMetadataValue("routeId", routeId);
            var observer = this._handlers[routeId];
            observer &amp;&amp; observer.map(function (value) {
                value(packet);
            });
        };
        Scene.prototype.completeConnectionInitialization = function (cr) {
            this.handle = cr.SceneHandle;
            for (var key in this.localRoutes) {
                var route = this.localRoutes[key];
                route.handle = cr.RouteMappings[key];
                this._handlers[route.handle] = route.handlers;
            }
        };
        /**
        Returns an Scene peer object that represents the scene host.
        @method Stormancer.Scene#host
        @return {object} A Scene peer object.
        */
        Scene.prototype.host = function () {
            return new Stormancer.ScenePeer(this.hostConnection, this.handle, this.remoteRoutes, this);
        };
        /**
        Registers a component and provide a factory for getting it.
        @method Stormancer.Scene#registerComponent
        @param {string} componentName The component game.
        @param {function} factory The factory function for getting the component.
        */
        Scene.prototype.registerComponent = function (componentName, factory) {
            this._registeredComponents[componentName] = factory;
        };
        /**
        Returns a specific registered component.
        @method Stormancer.Scene#getComponent
        @return {object} The wanted object.
        */
        Scene.prototype.getComponent = function (componentName) {
            return this._registeredComponents[componentName]();
        };
        Scene.prototype.getRemoteRoutes = function () {
            var result = [];
            for (var key in this.remoteRoutes) {
                result.push(this.remoteRoutes[key]);
            }
            return result;
        };
        return Scene;
    })();
    Stormancer.Scene = Scene;
})(Stormancer || (Stormancer = {}));
var Stormancer;
(function (Stormancer) {
    var SceneEndpoint = (function () {
        function SceneEndpoint() {
        }
        return SceneEndpoint;
    })();
    Stormancer.SceneEndpoint = SceneEndpoint;
    var ConnectionData = (function () {
        function ConnectionData() {
        }
        return ConnectionData;
    })();
    Stormancer.ConnectionData = ConnectionData;
})(Stormancer || (Stormancer = {}));
var Stormancer;
(function (Stormancer) {
    var ScenePeer = (function () {
        function ScenePeer(connection, sceneHandle, routeMapping, scene) {
            this._connection = connection;
            this._sceneHandle = sceneHandle;
            this._routeMapping = routeMapping;
            this._scene = scene;
            this.serializer = connection.serializer;
        }
        ScenePeer.prototype.id = function () {
            return this._connection.id;
        };
        ScenePeer.prototype.send = function (route, data, priority, reliability) {
            var r = this._routeMapping[route];
            if (!r) {
                throw new Error("The route " + route + " is not declared on the server.");
            }
            this._connection.sendToScene(this._sceneHandle, r.handle, data, priority, reliability);
        };
        ScenePeer.prototype.getComponent = function (componentName) {
            return this._connection.getComponent(componentName);
        };
        return ScenePeer;
    })();
    Stormancer.ScenePeer = ScenePeer;
})(Stormancer || (Stormancer = {}));
/// &lt;reference path="typings/jquery/jquery.d.ts" />
/*!{id:msgpack.js,ver:1.05,license:"MIT",author:"uupaa.js@gmail.com"}*/
this.msgpack || (function (globalScope) {
    globalScope.msgpack = {
        pack: msgpackpack,
        //              toString:Boolean = false):ByteArray/ByteString/false
        //  [1][mix to String]    msgpack.pack({}, true) -> "..."
        //  [2][mix to ByteArray] msgpack.pack({})       -> [...]
        unpack: msgpackunpack,
        //  [1][String to mix]    msgpack.unpack("...") -> {}
        //  [2][ByteArray to mix] msgpack.unpack([...]) -> {}
        worker: "msgpack.js",
        upload: msgpackupload,
        download: msgpackdownload // msgpack.download(url:String, option:Hash, callback:Function)
    };
    var _ie = /MSIE/.test(navigator.userAgent), _bin2num = {}, _num2bin = {}, _num2b64 = ("ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "abcdefghijklmnopqrstuvwxyz0123456789+/").split(""), _buf = [], _idx = 0, _error = 0, _isArray = Array.isArray || (function (mix) {
        return Object.prototype.toString.call(mix) === "[object Array]";
    }), _toString = String.fromCharCode, _MAX_DEPTH = 512;
    // for WebWorkers Code Block
    self.importScripts &amp;&amp; (onmessage = function (event) {
        if (event.data.method === "pack") {
            window.postMessage(base64encode(msgpackpack(event.data.data)));
        }
        else {
            window.postMessage(msgpackunpack(event.data.data));
        }
    });
    // msgpack.pack
    function msgpackpack(data, // @param Mix:
        settings) {
        // @return ByteArray/BinaryString/false:
        //     false is error return
        //  [1][mix to String]    msgpack.pack({}, true) -> "..."
        //  [2][mix to ByteArray] msgpack.pack({})       -> [...]
        var toString = false;
        _error = 0;
        if (!settings) {
            settings = { byteProperties: [] };
        }
        var byteArray = encode([], data, 0, settings);
        return _error ? false : toString ? byteArrayToByteString(byteArray) : byteArray;
    }
    // msgpack.unpack
    function msgpackunpack(data, settings) {
        // @return Mix/undefined:
        //       undefined is error return
        //  [1][String to mix]    msgpack.unpack("...") -> {}
        //  [2][ByteArray to mix] msgpack.unpack([...]) -> {}
        if (!settings) {
            settings = { byteProperties: [] };
        }
        _buf = typeof data === "string" ? toByteArray(data) : data;
        _idx = -1;
        return decode(settings); // mix or undefined
    }
    // inner - encoder
    function encode(rv, // @param ByteArray: result
        mix, // @param Mix: source data
        depth, // @param Number: depth
        settings, bytesArray) {
        var size, i, iz, c, pos, high, low, sign, exp, frac; // for IEEE754
        if (mix == null) {
            rv.push(0xc0);
        }
        else if (mix === false) {
            rv.push(0xc2);
        }
        else if (mix === true) {
            rv.push(0xc3);
        }
        else {
            switch (typeof mix) {
                case "number":
                    if (mix !== mix) {
                        rv.push(0xcb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff); // quiet NaN
                    }
                    else if (mix === Infinity) {
                        rv.push(0xcb, 0x7f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00); // positive infinity
                    }
                    else if (Math.floor(mix) === mix) {
                        if (mix &lt; 0) {
                            // int
                            if (mix >= -32) {
                                rv.push(0xe0 + mix + 32);
                            }
                            else if (mix > -0x80) {
                                rv.push(0xd0, mix + 0x100);
                            }
                            else if (mix > -0x8000) {
                                mix += 0x10000;
                                rv.push(0xd1, mix >> 8, mix &amp; 0xff);
                            }
                            else if (mix > -0x80000000) {
                                mix += 0x100000000;
                                rv.push(0xd2, mix >>> 24, (mix >> 16) &amp; 0xff, (mix >> 8) &amp; 0xff, mix &amp; 0xff);
                            }
                            else {
                                high = Math.floor(mix / 0x100000000);
                                low = mix &amp; 0xffffffff;
                                rv.push(0xd3, (high >> 24) &amp; 0xff, (high >> 16) &amp; 0xff, (high >> 8) &amp; 0xff, high &amp; 0xff, (low >> 24) &amp; 0xff, (low >> 16) &amp; 0xff, (low >> 8) &amp; 0xff, low &amp; 0xff);
                            }
                        }
                        else {
                            // uint
                            if (mix &lt; 0x80) {
                                rv.push(mix); // positive fixnum
                            }
                            else if (mix &lt; 0x100) {
                                rv.push(0xcc, mix);
                            }
                            else if (mix &lt; 0x10000) {
                                rv.push(0xcd, mix >> 8, mix &amp; 0xff);
                            }
                            else if (mix &lt; 0x100000000) {
                                rv.push(0xce, mix >>> 24, (mix >> 16) &amp; 0xff, (mix >> 8) &amp; 0xff, mix &amp; 0xff);
                            }
                            else {
                                high = Math.floor(mix / 0x100000000);
                                low = mix &amp; 0xffffffff;
                                rv.push(0xcf, (high >> 24) &amp; 0xff, (high >> 16) &amp; 0xff, (high >> 8) &amp; 0xff, high &amp; 0xff, (low >> 24) &amp; 0xff, (low >> 16) &amp; 0xff, (low >> 8) &amp; 0xff, low &amp; 0xff);
                            }
                        }
                    }
                    else {
                        // THX!! @edvakf
                        // http://javascript.g.hatena.ne.jp/edvakf/20101128/1291000731
                        sign = mix &lt; 0;
                        sign &amp;&amp; (mix *= -1);
                        // add offset 1023 to ensure positive
                        // 0.6931471805599453 = Math.LN2;
                        exp = ((Math.log(mix) / 0.6931471805599453) + 1023) | 0;
                        // shift 52 - (exp - 1023) bits to make integer part exactly 53 bits,
                        // then throw away trash less than decimal point
                        frac = mix * Math.pow(2, 52 + 1023 - exp);
                        //  S+-Exp(11)--++-----------------Fraction(52bits)-----------------------+
                        //  ||          ||                                                        |
                        //  v+----------++--------------------------------------------------------+
                        //  00000000|00000000|00000000|00000000|00000000|00000000|00000000|00000000
                        //  6      5    55  4        4        3        2        1        8        0
                        //  3      6    21  8        0        2        4        6
                        //
                        //  +----------high(32bits)-----------+ +----------low(32bits)------------+
                        //  |                                 | |                                 |
                        //  +---------------------------------+ +---------------------------------+
                        //  3      2    21  1        8        0
                        //  1      4    09  6
                        low = frac &amp; 0xffffffff;
                        sign &amp;&amp; (exp |= 0x800);
                        high = ((frac / 0x100000000) &amp; 0xfffff) | (exp &lt;&lt; 20);
                        rv.push(0xcb, (high >> 24) &amp; 0xff, (high >> 16) &amp; 0xff, (high >> 8) &amp; 0xff, high &amp; 0xff, (low >> 24) &amp; 0xff, (low >> 16) &amp; 0xff, (low >> 8) &amp; 0xff, low &amp; 0xff);
                    }
                    break;
                case "string":
                    // http://d.hatena.ne.jp/uupaa/20101128
                    iz = mix.length;
                    pos = rv.length; // keep rewrite position
                    rv.push(0); // placeholder
                    for (i = 0; i &lt; iz; ++i) {
                        c = mix.charCodeAt(i);
                        if (c &lt; 0x80) {
                            rv.push(c &amp; 0x7f);
                        }
                        else if (c &lt; 0x0800) {
                            rv.push(((c >>> 6) &amp; 0x1f) | 0xc0, (c &amp; 0x3f) | 0x80);
                        }
                        else if (c &lt; 0x10000) {
                            rv.push(((c >>> 12) &amp; 0x0f) | 0xe0, ((c >>> 6) &amp; 0x3f) | 0x80, (c &amp; 0x3f) | 0x80);
                        }
                    }
                    size = rv.length - pos - 1;
                    if (size &lt; 32) {
                        rv[pos] = 0xa0 + size; // rewrite
                    }
                    else if (size &lt; 0x10000) {
                        rv.splice(pos, 1, 0xda, size >> 8, size &amp; 0xff);
                    }
                    else if (size &lt; 0x100000000) {
                        rv.splice(pos, 1, 0xdb, size >>> 24, (size >> 16) &amp; 0xff, (size >> 8) &amp; 0xff, size &amp; 0xff);
                    }
                    break;
                default:
                    if (++depth >= _MAX_DEPTH) {
                        _error = 1; // CYCLIC_REFERENCE_ERROR
                        return rv = []; // clear
                    }
                    if (_isArray(mix)) {
                        if (bytesArray) {
                            size = mix.length;
                            if (size &lt; 32) {
                                rv.push(0xa0 + size);
                            }
                            else if (size &lt; 0x10000) {
                                rv.push(0xda, size >> 8, size &amp; 0xff);
                            }
                            else if (size &lt; 0x100000000) {
                                rv.push(0xdb, size >>> 24, (size >> 16) &amp; 0xff, (size >> 8) &amp; 0xff, size &amp; 0xff);
                            }
                            for (i = 0; i &lt; size; ++i) {
                                rv.push(mix[i]);
                            }
                        }
                        else {
                            size = mix.length;
                            if (size &lt; 16) {
                                rv.push(0x90 + size);
                            }
                            else if (size &lt; 0x10000) {
                                rv.push(0xdc, size >> 8, size &amp; 0xff);
                            }
                            else if (size &lt; 0x100000000) {
                                rv.push(0xdd, size >>> 24, (size >> 16) &amp; 0xff, (size >> 8) &amp; 0xff, size &amp; 0xff);
                            }
                            for (i = 0; i &lt; size; ++i) {
                                encode(rv, mix[i], depth, settings);
                            }
                        }
                    }
                    else {
                        // http://d.hatena.ne.jp/uupaa/20101129
                        pos = rv.length; // keep rewrite position
                        rv.push(0); // placeholder
                        size = 0;
                        for (i in mix) {
                            if (typeof (mix[i]) == "function") {
                                continue;
                            }
                            ++size;
                            encode(rv, i, depth);
                            if ($.inArray(i, settings.byteProperties) != -1) {
                                encode(rv, mix[i], depth, settings, true);
                            }
                            else {
                                encode(rv, mix[i], depth, settings, false);
                            }
                        }
                        if (size &lt; 16) {
                            rv[pos] = 0x80 + size; // rewrite
                        }
                        else if (size &lt; 0x10000) {
                            rv.splice(pos, 1, 0xde, size >> 8, size &amp; 0xff);
                        }
                        else if (size &lt; 0x100000000) {
                            rv.splice(pos, 1, 0xdf, size >>> 24, (size >> 16) &amp; 0xff, (size >> 8) &amp; 0xff, size &amp; 0xff);
                        }
                    }
            }
        }
        return rv;
    }
    // inner - decoder
    function decode(settings, rawAsArray) {
        var size, i, iz, c, num = 0, sign, exp, frac, ary, hash, buf = _buf, type = buf[++_idx], key;
        if (type >= 0xe0) {
            return type - 0x100;
        }
        if (type &lt; 0xc0) {
            if (type &lt; 0x80) {
                return type;
            }
            if (type &lt; 0x90) {
                num = type - 0x80;
                type = 0x80;
            }
            else if (type &lt; 0xa0) {
                num = type - 0x90;
                type = 0x90;
            }
            else {
                num = type - 0xa0;
                type = 0xa0;
            }
        }
        switch (type) {
            case 0xc0: return null;
            case 0xc2: return false;
            case 0xc3: return true;
            case 0xca:
                num = buf[++_idx] * 0x1000000 + (buf[++_idx] &lt;&lt; 16) + (buf[++_idx] &lt;&lt; 8) + buf[++_idx];
                sign = num &amp; 0x80000000; //  1bit
                exp = (num >> 23) &amp; 0xff; //  8bits
                frac = num &amp; 0x7fffff; // 23bits
                if (!num || num === 0x80000000) {
                    return 0;
                }
                if (exp === 0xff) {
                    return frac ? NaN : Infinity;
                }
                return (sign ? -1 : 1) * (frac | 0x800000) * Math.pow(2, exp - 127 - 23);
            case 0xcb:
                num = buf[++_idx] * 0x1000000 + (buf[++_idx] &lt;&lt; 16) + (buf[++_idx] &lt;&lt; 8) + buf[++_idx];
                sign = num &amp; 0x80000000; //  1bit
                exp = (num >> 20) &amp; 0x7ff; // 11bits
                frac = num &amp; 0xfffff; // 52bits - 32bits (high word)
                if (!num || num === 0x80000000) {
                    _idx += 4;
                    return 0;
                }
                if (exp === 0x7ff) {
                    _idx += 4;
                    return frac ? NaN : Infinity;
                }
                num = buf[++_idx] * 0x1000000 + (buf[++_idx] &lt;&lt; 16) + (buf[++_idx] &lt;&lt; 8) + buf[++_idx];
                return (sign ? -1 : 1) * ((frac | 0x100000) * Math.pow(2, exp - 1023 - 20) + num * Math.pow(2, exp - 1023 - 52));
            case 0xcf:
                num = buf[++_idx] * 0x1000000 + (buf[++_idx] &lt;&lt; 16) + (buf[++_idx] &lt;&lt; 8) + buf[++_idx];
                return num * 0x100000000 + buf[++_idx] * 0x1000000 + (buf[++_idx] &lt;&lt; 16) + (buf[++_idx] &lt;&lt; 8) + buf[++_idx];
            case 0xce: num += buf[++_idx] * 0x1000000 + (buf[++_idx] &lt;&lt; 16);
            case 0xcd: num += buf[++_idx] &lt;&lt; 8;
            case 0xcc: return num + buf[++_idx];
            case 0xd3:
                num = buf[++_idx];
                if (num &amp; 0x80) {
                    return ((num ^ 0xff) * 0x100000000000000 + (buf[++_idx] ^ 0xff) * 0x1000000000000 + (buf[++_idx] ^ 0xff) * 0x10000000000 + (buf[++_idx] ^ 0xff) * 0x100000000 + (buf[++_idx] ^ 0xff) * 0x1000000 + (buf[++_idx] ^ 0xff) * 0x10000 + (buf[++_idx] ^ 0xff) * 0x100 + (buf[++_idx] ^ 0xff) + 1) * -1;
                }
                return num * 0x100000000000000 + buf[++_idx] * 0x1000000000000 + buf[++_idx] * 0x10000000000 + buf[++_idx] * 0x100000000 + buf[++_idx] * 0x1000000 + buf[++_idx] * 0x10000 + buf[++_idx] * 0x100 + buf[++_idx];
            case 0xd2:
                num = buf[++_idx] * 0x1000000 + (buf[++_idx] &lt;&lt; 16) + (buf[++_idx] &lt;&lt; 8) + buf[++_idx];
                return num &lt; 0x80000000 ? num : num - 0x100000000;
            case 0xd1:
                num = (buf[++_idx] &lt;&lt; 8) + buf[++_idx];
                return num &lt; 0x8000 ? num : num - 0x10000;
            case 0xd0:
                num = buf[++_idx];
                return num &lt; 0x80 ? num : num - 0x100;
            case 0xdb: num += buf[++_idx] * 0x1000000 + (buf[++_idx] &lt;&lt; 16);
            case 0xda: num += (buf[++_idx] &lt;&lt; 8) + buf[++_idx];
            case 0xa0:
                if (rawAsArray) {
                    for (ary = [], i = _idx, iz = i + num; i &lt; iz;) {
                        ary.push(buf[++i]);
                    }
                    _idx = i;
                    return ary;
                }
                else {
                    for (ary = [], i = _idx, iz = i + num; i &lt; iz;) {
                        c = buf[++i]; // lead byte
                        ary.push(c &lt; 0x80 ? c : c &lt; 0xe0 ? ((c &amp; 0x1f) &lt;&lt; 6 | (buf[++i] &amp; 0x3f)) : ((c &amp; 0x0f) &lt;&lt; 12 | (buf[++i] &amp; 0x3f) &lt;&lt; 6 | (buf[++i] &amp; 0x3f)));
                    }
                    _idx = i;
                    return ary.length &lt; 10240 ? _toString.apply(null, ary) : byteArrayToByteString(ary);
                }
            case 0xdf: num += buf[++_idx] * 0x1000000 + (buf[++_idx] &lt;&lt; 16);
            case 0xde: num += (buf[++_idx] &lt;&lt; 8) + buf[++_idx];
            case 0x80:
                hash = {};
                while (num--) {
                    // make key/value pair
                    size = buf[++_idx] - 0xa0;
                    for (ary = [], i = _idx, iz = i + size; i &lt; iz;) {
                        c = buf[++i]; // lead byte
                        ary.push(c &lt; 0x80 ? c : c &lt; 0xe0 ? ((c &amp; 0x1f) &lt;&lt; 6 | (buf[++i] &amp; 0x3f)) : ((c &amp; 0x0f) &lt;&lt; 12 | (buf[++i] &amp; 0x3f) &lt;&lt; 6 | (buf[++i] &amp; 0x3f)));
                    }
                    _idx = i;
                    key = _toString.apply(null, ary);
                    if ($.inArray(key, settings.byteProperties) != -1) {
                        hash[key] = decode(settings, true);
                    }
                    else {
                        hash[key] = decode(settings);
                    }
                }
                return hash;
            case 0xdd: num += buf[++_idx] * 0x1000000 + (buf[++_idx] &lt;&lt; 16);
            case 0xdc: num += (buf[++_idx] &lt;&lt; 8) + buf[++_idx];
            case 0x90:
                ary = [];
                while (num--) {
                    ary.push(decode(settings, rawAsArray));
                }
                return ary;
        }
        return;
    }
    // inner - byteArray To ByteString
    function byteArrayToByteString(byteArray) {
        try {
            return _toString.apply(this, byteArray); // toString
        }
        catch (err) {
            ;
        }
        var rv = [], i = 0, iz = byteArray.length, num2bin = _num2bin;
        for (; i &lt; iz; ++i) {
            rv[i] = num2bin[byteArray[i]];
        }
        return rv.join("");
    }
    // msgpack.download - load from server
    function msgpackdownload(url, // @param String:
        option, // @param Hash: { worker, timeout, before, after }
        //    option.worker - Boolean(= false): true is use WebWorkers
        //    option.timeout - Number(= 10): timeout sec
        //    option.before  - Function: before(xhr, option)
        //    option.after   - Function: after(xhr, option, { status, ok })
        callback) {
        //    data   - Mix/null:
        //    option - Hash:
        //    status - Number: HTTP status code
        //    ok     - Boolean:
        option.method = "GET";
        option.binary = true;
        ajax(url, option, callback);
    }
    // msgpack.upload - save to server
    function msgpackupload(url, // @param String:
        option, // @param Hash: { data, worker, timeout, before, after }
        //    option.data - Mix:
        //    option.worker - Boolean(= false): true is use WebWorkers
        //    option.timeout - Number(= 10): timeout sec
        //    option.before  - Function: before(xhr, option)
        //    option.after   - Function: after(xhr, option, { status, ok })
        callback) {
        //    data   - String: responseText
        //    option - Hash:
        //    status - Number: HTTP status code
        //    ok     - Boolean:
        option.method = "PUT";
        option.binary = true;
        if (option.worker &amp;&amp; globalScope.Worker) {
            var worker = new Worker(globalScope.msgpack.worker);
            worker.onmessage = function (event) {
                option.data = event.data;
                ajax(url, option, callback);
            };
            worker.postMessage({ method: "pack", data: option.data });
        }
        else {
            // pack and base64 encode
            option.data = base64encode(msgpackpack(option.data));
            ajax(url, option, callback);
        }
    }
    // inner -
    function ajax(url, // @param String:
        option, // @param Hash: { data, ifmod, method, timeout,
        //                header, binary, before, after, worker }
        //    option.data    - Mix: upload data
        //    option.ifmod   - Boolean: true is "If-Modified-Since" header
        //    option.method  - String: "GET", "POST", "PUT"
        //    option.timeout - Number(= 10): timeout sec
        //    option.header  - Hash(= {}): { key: "value", ... }
        //    option.binary  - Boolean(= false): true is binary data
        //    option.before  - Function: before(xhr, option)
        //    option.after   - Function: after(xhr, option, { status, ok })
        //    option.worker  - Boolean(= false): true is use WebWorkers
        callback) {
        //    data   - String/Mix/null:
        //    option - Hash:
        //    status - Number: HTTP status code
        //    ok     - Boolean:
        function readyStateChange() {
            if (xhr.readyState === 4) {
                var data, status = xhr.status, worker, byteArray, rv = { status: status, ok: status >= 200 &amp;&amp; status &lt; 300 };
                if (!run++) {
                    if (method === "PUT") {
                        data = rv.ok ? xhr.responseText : "";
                    }
                    else {
                        if (rv.ok) {
                            if (option.worker &amp;&amp; globalScope.Worker) {
                                worker = new Worker(globalScope.msgpack.worker);
                                worker.onmessage = function (event) {
                                    callback(event.data, option, rv);
                                };
                                worker.postMessage({
                                    method: "unpack",
                                    data: xhr.responseText
                                });
                                gc();
                                return;
                            }
                            else {
                                byteArray = _ie ? toByteArrayIE(xhr) : toByteArray(xhr.responseText);
                                data = msgpackunpack(byteArray);
                            }
                        }
                    }
                    after &amp;&amp; after(xhr, option, rv);
                    callback(data, option, rv);
                    gc();
                }
            }
        }
        function ng(abort, status) {
            if (!run++) {
                var rv = { status: status || 400, ok: false };
                after &amp;&amp; after(xhr, option, rv);
                callback(null, option, rv);
                gc(abort);
            }
        }
        function gc(abort) {
            abort &amp;&amp; xhr &amp;&amp; xhr.abort &amp;&amp; xhr.abort();
            watchdog &amp;&amp; (clearTimeout(watchdog), watchdog = 0);
            xhr = null;
            globalScope.addEventListener &amp;&amp; globalScope.removeEventListener("beforeunload", ng, false);
        }
        var watchdog = 0, method = option.method || "GET", header = option.header || {}, before = option.before, after = option.after, data = option.data || null, xhr = globalScope.XMLHttpRequest ? new XMLHttpRequest() : globalScope.ActiveXObject ? new ActiveXObject("Microsoft.XMLHTTP") : null, run = 0, i, overrideMimeType = "overrideMimeType", setRequestHeader = "setRequestHeader", getbinary = method === "GET" &amp;&amp; option.binary;
        try {
            xhr.onreadystatechange = readyStateChange;
            xhr.open(method, url, true); // ASync
            before &amp;&amp; before(xhr, option);
            getbinary &amp;&amp; xhr[overrideMimeType] &amp;&amp; xhr[overrideMimeType]("text/plain; charset=x-user-defined");
            data &amp;&amp; xhr[setRequestHeader]("Content-Type", "application/x-www-form-urlencoded");
            for (i in header) {
                xhr[setRequestHeader](i, header[i]);
            }
            globalScope.addEventListener &amp;&amp; globalScope.addEventListener("beforeunload", ng, false); // 400: Bad Request
            xhr.send(data);
            watchdog = setTimeout(function () {
                ng(1, 408); // 408: Request Time-out
            }, (option.timeout || 10) * 1000);
        }
        catch (err) {
            ng(0, 400); // 400: Bad Request
        }
    }
    // inner - BinaryString To ByteArray
    function toByteArray(data) {
        // @return ByteArray: [0x00, 0x01]
        var rv = [], bin2num = _bin2num, remain, ary = data.split(""), i = -1, iz;
        iz = ary.length;
        remain = iz % 8;
        while (remain--) {
            ++i;
            rv[i] = bin2num[ary[i]];
        }
        remain = iz >> 3;
        while (remain--) {
            rv.push(bin2num[ary[++i]], bin2num[ary[++i]], bin2num[ary[++i]], bin2num[ary[++i]], bin2num[ary[++i]], bin2num[ary[++i]], bin2num[ary[++i]], bin2num[ary[++i]]);
        }
        return rv;
    }
    // inner - BinaryString to ByteArray
    function toByteArrayIE(xhr) {
        var rv = [], data, remain, charCodeAt = "charCodeAt", loop, v0, v1, v2, v3, v4, v5, v6, v7, i = -1, iz;
        iz = vblen(xhr);
        data = vbstr(xhr);
        loop = Math.ceil(iz / 2);
        remain = loop % 8;
        while (remain--) {
            v0 = data[charCodeAt](++i); // 0x00,0x01 -> 0x0100
            rv.push(v0 &amp; 0xff, v0 >> 8);
        }
        remain = loop >> 3;
        while (remain--) {
            v0 = data[charCodeAt](++i);
            v1 = data[charCodeAt](++i);
            v2 = data[charCodeAt](++i);
            v3 = data[charCodeAt](++i);
            v4 = data[charCodeAt](++i);
            v5 = data[charCodeAt](++i);
            v6 = data[charCodeAt](++i);
            v7 = data[charCodeAt](++i);
            rv.push(v0 &amp; 0xff, v0 >> 8, v1 &amp; 0xff, v1 >> 8, v2 &amp; 0xff, v2 >> 8, v3 &amp; 0xff, v3 >> 8, v4 &amp; 0xff, v4 >> 8, v5 &amp; 0xff, v5 >> 8, v6 &amp; 0xff, v6 >> 8, v7 &amp; 0xff, v7 >> 8);
        }
        iz % 2 &amp;&amp; rv.pop();
        return rv;
    }
    // inner - base64.encode
    function base64encode(data) {
        // @return Base64String:
        var rv = [], c = 0, i = -1, iz = data.length, pad = [0, 2, 1][data.length % 3], num2bin = _num2bin, num2b64 = _num2b64;
        if (globalScope.btoa) {
            while (i &lt; iz) {
                rv.push(num2bin[data[++i]]);
            }
            return btoa(rv.join(""));
        }
        --iz;
        while (i &lt; iz) {
            c = (data[++i] &lt;&lt; 16) | (data[++i] &lt;&lt; 8) | (data[++i]); // 24bit
            rv.push(num2b64[(c >> 18) &amp; 0x3f], num2b64[(c >> 12) &amp; 0x3f], num2b64[(c >> 6) &amp; 0x3f], num2b64[c &amp; 0x3f]);
        }
        pad > 1 &amp;&amp; (rv[rv.length - 2] = "=");
        pad > 0 &amp;&amp; (rv[rv.length - 1] = "=");
        return rv.join("");
    }
    // --- init ---
    (function () {
        var i = 0, v;
        for (; i &lt; 0x100; ++i) {
            v = _toString(i);
            _bin2num[v] = i; // "\00" -> 0x00
            _num2bin[i] = v; //     0 -> "\00"
        }
        for (i = 0x80; i &lt; 0x100; ++i) {
            _bin2num[_toString(0xf700 + i)] = i; // "\f780" -> 0x80
        }
    })();
    _ie &amp;&amp; document.write('&lt;script type="text/vbscript">\
Function vblen(b)vblen=LenB(b.responseBody)End Function\n\
Function vbstr(b)vbstr=CStr(b.responseBody)+chr(0)End Function&lt;/' + 'script>');
})(this);
/// &lt;reference path="Scripts/msgPack.ts" />
/**
@namespace Stormancer
*/
var Stormancer;
(function (Stormancer) {
    var jQueryWrapper = (function () {
        function jQueryWrapper() {
        }
        jQueryWrapper.initWrapper = function (jquery) {
            jQueryWrapper.$ = jquery;
        };
        return jQueryWrapper;
    })();
    Stormancer.jQueryWrapper = jQueryWrapper;
})(Stormancer || (Stormancer = {}));
(function ($, window) {
    Stormancer.jQueryWrapper.initWrapper($);
    $.stormancer = function (configuration) {
        return new Stormancer.Client(configuration);
    };
    //jQuery.support.cors = true
}(jQuery, window));
var Stormancer;
(function (Stormancer) {
    var WebSocketConnection = (function () {
        function WebSocketConnection(id, socket) {
            // Metadata associated with the connection.
            this.metadata = {};
            this.serializerChosen = false;
            this.serializer = new Stormancer.MsgPackSerializer();
            this._registeredComponents = { "serializer": this.serializer };
            this.id = id;
            this._socket = socket;
            this.connectionDate = new Date();
            this.state = 2 /* Connected */;
        }
        // Close the connection
        WebSocketConnection.prototype.close = function () {
            this._socket.close();
        };
        // Sends a system message to the peer.
        WebSocketConnection.prototype.sendSystem = function (msgId, data, priority) {
            if (priority === void 0) { priority = 2 /* MEDIUM_PRIORITY */; }
            var bytes = new Uint8Array(data.length + 1);
            bytes[0] = msgId;
            bytes.set(data, 1);
            this._socket.send(bytes.buffer);
        };
        // Sends a packet to the target remote scene.
        WebSocketConnection.prototype.sendToScene = function (sceneIndex, route, data, priority, reliability) {
            var bytes = new Uint8Array(data.length + 3);
            bytes[0] = sceneIndex;
            var ushorts = new Uint16Array(1);
            ushorts[0] = route;
            bytes.set(new Uint8Array(ushorts.buffer), 1);
            bytes.set(data, 3);
            this._socket.send(bytes.buffer);
        };
        WebSocketConnection.prototype.setApplication = function (account, application) {
            this.account = account;
            this.application = application;
        };
        WebSocketConnection.prototype.registerComponent = function (componentName, component) {
            this._registeredComponents[componentName] = component;
        };
        WebSocketConnection.prototype.getComponent = function (componentName) {
            return this._registeredComponents[componentName]();
        };
        return WebSocketConnection;
    })();
    Stormancer.WebSocketConnection = WebSocketConnection;
})(Stormancer || (Stormancer = {}));
var Stormancer;
(function (Stormancer) {
    var WebSocketTransport = (function () {
        function WebSocketTransport() {
            this.name = "websocket";
            // Gets a boolean indicating if the transport is currently running.
            this.isRunning = false;
            this._connecting = false;
            // Fires when the transport recieves new packets.
            this.packetReceived = [];
            // Fires when a remote peer has opened a connection.
            this.connectionOpened = [];
            // Fires when a connection to a remote peer is closed.
            this.connectionClosed = [];
        }
        // Starts the transport
        WebSocketTransport.prototype.start = function (type, handler, token) {
            this._type = name;
            this._connectionManager = handler;
            this.isRunning = true;
            token.onCancelled(this.stop);
            var deferred = $.Deferred();
            deferred.resolve();
            return deferred.promise();
        };
        WebSocketTransport.prototype.stop = function () {
            this.isRunning = false;
            if (this._socket) {
                this._socket.close();
                this._socket = null;
            }
        };
        // Connects the transport to a remote host.
        WebSocketTransport.prototype.connect = function (endpoint) {
            var _this = this;
            if (!this._socket &amp;&amp; !this._connecting) {
                this._connecting = true;
                var socket = new WebSocket(endpoint + "/");
                socket.binaryType = "arraybuffer";
                socket.onmessage = function (args) { return _this.onMessage(args.data); };
                this._socket = socket;
                var result = $.Deferred();
                socket.onclose = function (args) { return _this.onClose(result, args); };
                socket.onopen = function () { return _this.onOpen(result); };
                return result.promise();
            }
            throw new Error("This transport is already connected.");
        };
        WebSocketTransport.prototype.createNewConnection = function (socket) {
            var cid = this._connectionManager.generateNewConnectionId();
            return new Stormancer.WebSocketConnection(cid, socket);
        };
        WebSocketTransport.prototype.onOpen = function (deferred) {
            this._connecting = false;
            var connection = this.createNewConnection(this._socket);
            this._connectionManager.newConnection(connection);
            this.connectionOpened.map(function (action) {
                action(connection);
            });
            this._connection = connection;
            deferred.resolve(connection);
        };
        WebSocketTransport.prototype.onMessage = function (buffer) {
            var data = new Uint8Array(buffer);
            if (this._connection) {
                var packet = new Stormancer.Packet(this._connection, data);
                if (data[0] === Stormancer.MessageIDTypes.ID_CONNECTION_RESULT) {
                    this.id = data.subarray(1, 9);
                }
                else {
                    this.packetReceived.map(function (action) {
                        action(packet);
                    });
                }
            }
        };
        WebSocketTransport.prototype.onClose = function (deferred, closeEvent) {
            var _this = this;
            if (!this._connection) {
                this._connecting = false;
                deferred.reject(new Error("Can't connect WebSocket to server. Error code: " + closeEvent.code + ". Reason: " + closeEvent.reason + "."));
                this._socket = null;
            }
            else {
                var reason = closeEvent.wasClean ? "CLIENT_DISCONNECTED" : "CONNECTION_LOST";
                if (this._connection) {
                    this._connectionManager.closeConnection(this._connection, reason);
                    this.connectionClosed.map(function (action) {
                        action(_this._connection);
                    });
                }
            }
        };
        return WebSocketTransport;
    })();
    Stormancer.WebSocketTransport = WebSocketTransport;
})(Stormancer || (Stormancer = {}));
//# sourceMappingURL=stormancer.js.map</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Stormancer.Client.html">Client</a></li><li><a href="Stormancer.Configuration.html">Configuration</a></li><li><a href="Stormancer.Packet.html">Packet</a></li><li><a href="Stormancer.Route.html">Route</a></li><li><a href="Stormancer.Scene.html">Scene</a></li></ul><h3>Namespaces</h3><ul><li><a href="Stormancer.html">Stormancer</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.2</a> on Wed Aug 12 2015 18:29:43 GMT+0200 (Paris, Madrid (heure d’été))
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
